#lang racket

(require racket/format)

; create a pesudo-random number generator
; from now on, pseudo-random integers in [0 .. k-1] can be generated by
; (random k prg)
(define prg (make-pseudo-random-generator))

; non-zero test
(define (non-zero? n) (not (zero? n)))

; declare a structure for the game, with 2 fields:
;   board: will store the 4x4 table of cells with values with content either
;          0 (for unoccupied cell), or a power of 2
;   score: the current score of the played game
(struct Game (board score) #:transparent)

; viewer of the current state of the game
(define (show game)
  (displayln (format "Score: ~a" (Game-score game)))
  (map (lambda (row)
         (map (lambda (cell)
                (display "|")
                (display (if (= cell 0) ".   " (~v cell #:width 4))))
              row)
         (displayln "|"))
       (Game-board game)))

; (zero-replace n v list) replaces the n-th zero in the list l with v
(define (zero-replace n v l)
     (if (equal? (car l) 0)
         (if (equal? (- n 1) 0)
             (append (list v) (cdr l))
             (append (list (car l)) (zero-replace (- n 1) v (cdr l)))
         )
         (append (list (car l)) (zero-replace n v (cdr l)))
     )

)

; (split-4 l) splits a list elements into chunks of lists of 4 elements
(define (split-4 l)
  (if (null? l) l (cons (take l 4) (split-4 (drop l 4)))))

; (placeRandomCell game) places randomly value 2 or 4 in an empty cell of 'game'
; and returns as value the new game
(define (placeRandomCell game)
  (let* ([cell-list (apply append (Game-board game))]
         [empty-cells 
          (length (filter zero? cell-list))]
         [random-empty-cell (+ (random empty-cells prg) 1)]
         [random-value (* 2 (+ (random 2 prg) 1))])
    (Game 
     (split-4 (zero-replace random-empty-cell random-value cell-list))
     (Game-score game))))

; initializer of the game
(define (init-game) 
  (placeRandomCell 
   (placeRandomCell (Game 
                     '((0 0 0 0) 
                       (0 0 0 0) 
                       (0 0 0 0) 
                       (0 0 0 0)) 
                     0))))

; (collapseRow row) collapses the values of a row as if it's tiles are shifted to the left.
; After collapsing neighboring tiles with same value, zeroes are added to its end, if needed, to represent the empty tiles 
; to the right of the row.
; Finally, the sum of values of the tiles produced by collisions is cons-ed to the front of the row.
; Thus, the result is the new row prefixed with the value produced by colisions during the left shift.
; This function can be implemented by nested if's to perform case distinction:
;  - if row has length 0, 1, 2, 3, 4 ; if some neighboring elements ar equal; etc.
(define (collapseRow row)
    (append (list (get-value row)) (put-zeros (collapseRow-acc row) 4))
)

(define (put-zeros l n)
    (if (< (length l) n) (put-zeros (append l '(0)) n) l)
)

(define (skip n l)
  (cond
    [(= n 0) l]
    [else (skip (- n 1) (cdr l))]
  )
)

(define (caar l) (car (cdr l)))

(define (get-value row)
    (cond
        [(<= (length row) 1) 0]
        [(= (car row) 0) (get-value (cdr row))]
        [(= (car row) (caar row))
         (+ (* 2 (car row)) (get-value (skip 2 row)))]
        [else (get-value (cdr row))]
    )
)

(define (collapseRow-acc row)
    (cond
        [(<= (length row) 1) row]
        [(= (car row) 0) (collapseRow-acc (cdr row))]
        [(= (car row) (caar row))
         (cons (* 2 (car row)) (collapseRow-acc (skip 2 row)))]
        [else (cons (car row) (collapseRow-acc (cdr row)))]
    )
)

; detect neighbor cells in a row
(define (neighbor-cells? row)
  (let ([neighbor-cells-aux 
         (lambda (a b c d) (or (= a b) (= b c) (= c d)))])
    (apply neighbor-cells-aux row)))

(define (horizontalCollisions? rows)
  (if (= (length rows) 1) 
      (neighbor-cells? (car rows))
      (or (neighbor-cells? (car rows)) (horizontalCollisions? (cdr rows)))))

; detect if the game is won
;
(define (isWon? game)
    (= (apply max (car (Game-board game))) 2048))

; detect if the game is lost
(define (isLost? game)
  (cond
      [(isWon? game) #f]
      [(= (apply min (car (Game-board game))) 0) #f]
      [(not (equal? game (moveDown game))) #f]
      [(not (equal? game (moveRight game))) #f]
      [(not (equal? game (moveUp game))) #f]
      [(not (equal? game (moveLeft game))) #f]
      [else #t])
)

; transpose a matrix
(define (transpose A) 
  (if (eq? (length (car A)) 0) 
      null
      (cons (map car A) (transpose (map cdr A)))))

; MOVES

; (moveLeft game) simulates the shift of all tiles to the left
; the left shift of a row is performed as follows:
; 1) we remove all zero cells from a row; e.g., '(4 0 4 8) --> '(4 4 8)
;    this allows am east detection of colliding cells (e.g., 4,4 are colliding horizontal cells)
; 2) (collapseRow row-without-zero) performs all collisions, adds zero tiles to the end of the collapsed lists,
;    and adds the score of collisions on that row, as first element. 
;    We call such a row a 'row with score'
;    Examples: '() represents the empty row. No collisions occur => result '(0 0 0 0 0)
;              '(4 4 8) may represent any of the rows '(0 4 4 8) '(4 0 4 8) '(4 4 8 0) => result '(8 8 8 0 0)
; 3) the board of new game is list of 'rows with score', from which we drop the first element (the score)
; 4) the score of the new game is the old score, to which we add the scores from all 'rows with score'
;    In Racket, this computation is a simple call of (foldr + ...)
(define (moveLeft game)
  (define rows-with-score
    (map (compose collapseRow (lambda (row) (filter non-zero? row))) 
                      (Game-board game)))
  (Game (map cdr rows-with-score) 
        (foldr + (Game-score game) (map car rows-with-score))))
; moveUp simulates the shift up of all tiles
; Note that a moveUp coincides with a transpose of the moveLeft of the transposed board
(define (moveUp game)
  (define rows-with-score
    (map (compose collapseRow (lambda (row) (filter non-zero? row)))
                      (transpose (Game-board game))))
  (Game (transpose (map cdr rows-with-score))
        (foldr + (Game-score game) (map car rows-with-score))))

; moveDown simulates the shift down of all tiles
; Note that a moveDown can be simulated as follows:
;    1) we perform a moveRight of the transpose of the board obtained by reversing all rows.
;    2) The new board is obtained by reversing the rows of the previously computed board, 
;       and then transposing it
(define (moveDown game)
  (define rows-with-score
    (map (compose collapseRow (lambda (row) (filter non-zero? row)))
                      (map reverse(transpose (map reverse (Game-board game))))))
  (Game (map reverse (transpose (map reverse (map cdr rows-with-score))))
        (foldr + (Game-score game) (map car rows-with-score))))

; moveRight simulates the shift to the right of all tiles
; Note that a moveRight can be simulated as follows:
;    1) we perform a moveLeft of the board obtained by reversing all rows.
;    2) The new board is obtained by reversing the rows of the previously computed board
(define (moveRight game)
  (define rows-with-score
    (map (compose collapseRow (lambda (row) (filter non-zero? row)))
                      (map reverse (Game-board game))))
  (Game (map reverse (map cdr rows-with-score)) 
        (foldr + (Game-score game) (map car rows-with-score))))

; a functional that returns the function that performs the move 
; chosen by the user 
;   a             -> moveLeft
;   s             -> moveDown
;   w             -> moveUp
;   d             -> moveRight
;   anything-else -> no move (that is, identity function)
(define (getMove)
  (display "Next move [w/a/s/d]: ")
  (let ([k (read)])
    (if (eq? k 'w) moveUp
        (if (eq? k 'a) moveLeft
            (if (eq? k 's) moveDown
                (if (eq? k 'd) moveRight
                    (lambda (x) (displayln "Unknown move") x)))))))

(define (play game)
  (show game)
  (if (isWon? game)
      (displayln "Winner!")
      (if (isLost? game)
          (displayln "Game over!")
          (let ([newgame ((getMove) game)])
            (play (if (equal? game newgame)
                      newgame
                      (placeRandomCell newgame)))))))

(define (interactive) (play (init-game)))

;apply a list of function to an element
(define (apply-function-list flist element)
  (map (lambda (f)
         (f element))
       flist))

;get the number of zeros from a game
(define (get-zeros game)
  (list (foldr (lambda (x y) (+ (length x) y)) 0 (map (lambda (x) (filter zero? x)) 
       (Game-board game))) game)
)

;sort the games by their zeros number
(define (decide-next lst)
     (car (cdr (car (cdr (sort lst #:key car >)))))
)

(define (choose-next-game game)
  ;decide what game to choose next
  (decide-next
         ;get all zeros from each game
         (map get-zeros
              ;execute all the possible moves
              (apply-function-list (list moveDown moveUp moveLeft moveRight) game)))
  )

(define (solitary) (play-solitary (init-game)))

(define (play-solitary game)
  (show game)
  (if (isWon? game)
      (displayln "Winner!")
      (if (isLost? game)
          (displayln "Game over!")
          (begin

            (play-solitary (placeRandomCell (choose-next-game game)))))))
